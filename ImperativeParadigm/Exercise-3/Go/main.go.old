package main

import (
	"fmt"
	"math/rand"
	"reflect"
	"time"
)

const (
	LEFT = iota
	RIGHT
)

// areParamsValid checks if the parameters are valid
// and returns an error if not.
//
// elements must be a pointer to a slice,
// amount must be positive,
// direction must be LEFT (0) or RIGHT (1)
func areParamsValid(elements any, amount int, direction int) error {
	// Check if elements is a slice
	if elemType := reflect.TypeOf(elements); !(elemType.Kind() == reflect.Ptr && elemType.Elem().Kind() == reflect.Slice) {
		return fmt.Errorf("elements must be a pointer to a slice")
	}

	// Check if amount is positive
	if amount < 0 {
		return fmt.Errorf("amount must be positive")
	}

	// Check if direction is valid
	if direction != LEFT && direction != RIGHT {
		return fmt.Errorf("direction must be LEFT (0) or RIGHT (1)")
	}

	return nil
}

// rotate rotates the elements of a slice by the given amount
// in the given direction.
//
// elements could be a pointer to a slice of any type.
//
// Example:
//
//	elements = [1, 2, 3, 4, 5]
//	amount = 2
//	direction = LEFT
//	result = [3, 4, 5, 1, 2]
func rotateSlice(elements any, amount int, direction int) error {
	if err := areParamsValid(elements, amount, direction); err != nil {
		return err
	}

	// Get the value of the elements pointer
	elementsValue := reflect.ValueOf(elements).Elem()

	// Get the length of the elements
	length := elementsValue.Len()

	swap := reflect.Swapper(elementsValue.Interface())
	if direction == LEFT {
		for j := 0; j < amount; j++ {
			firstElement := elementsValue.Index(0).Interface()
			for i := 0; i < length-1; i++ {
				swap(i, i+1)
			}
			elementsValue.Index(length - 1).Set(reflect.ValueOf(firstElement))
		}
	} else {
		for j := 0; j < amount; j++ {
			lastElement := elementsValue.Index(length - 1).Interface()
			for i := length - 1; i > 0; i-- {
				swap(i, i-1)
			}
			elementsValue.Index(0).Set(reflect.ValueOf(lastElement))
		}
	}

	return nil
}

func main() {
	// Create a new private random source with a custom seed
	random := rand.New(rand.NewSource(time.Now().UnixNano()))

	// Create a slice of 10 integers
	elements := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	var ptrToElements any = &elements

	for i := 0; i < 10; i++ {
		// Rotate the elements by a random amount in a random direction
		amount := random.Intn(9) + 1 // To ignore 0
		direction := random.Intn(2)

		fmt.Printf("Slice: %v\n", elements)

		err := rotateSlice(ptrToElements, amount, direction)
		if err != nil {
			panic(err)
		}

		fmt.Printf("Has been rotated by %d", amount)
		if direction == LEFT {
			fmt.Printf(" to the left\n")
		} else {
			fmt.Printf(" to the right\n")
		}
		fmt.Printf("Result: %v\n\n", elements)
	}
}
